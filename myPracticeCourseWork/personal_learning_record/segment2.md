[Contents](../personal_learning_record/personal_learning_record.md) | [Segment 2 - Languages and OS](../personal_learning_record/segment2.md) 

# Segment 2 - Languages and Operating Systems

## session 5
High Level Languages; Assembly Codes; Machine Codes Binary instructions directly run by the CPU form machine code. An assembler generates machine code from a human-readable form of machine code, assembly code. High-level languages as Python, Java, and C transform into machine code for runtime and enable one easily design difficult jobs.

By using CPUlator, I have been exposed to ARM Assembler and C programming which clarifies how assembly language interacts with hardware and how C code gets translocated into machine code.

Stack-based programming also makes use of subroutines, little reusable chunks of code. Understanding this allows me to allocate RAM sensibly and organise projects.

Interrupts let the CPU react to outside events, therefore stopping its current flow and allowing it to manage critical tasks. Hardware resource management and multitasking call for knowledge of disruptions.

Examining assembly samples has helped me to see how low-level instructions impact hardware components including memory and registers as well as program construction.
## session 6
Structured Approach Contemporary Operating Systems Starting research on the architecture of contemporary operating systems has helped me to understand how they manage hardware, software, and resources to guarantee seamless task and service functioning.

Assembly of CPUs and C Code Especially in simulating and manipulating 7-segment displays on CPUator, I have been studying Assembler and C programs. This exercise has helped me to understand how low-level programming might influence physical components.

Having gone on to apply Assembler and C programming to the Raspberry Pi, therefore transcending simulation and allowing me to interact with actual hardware, I have moved on from learning in theory. This practical awareness helps me to interact with real technologies more responsibly.
## session 7
I started this session looking at the many elements and their interactions inside the larger framework of operating systems. This covered knowledge of system utilities, user interfaces, and several system services including their organisational framework.

Understanding Linux's special features in terms of file management, process handling, and system configuration compared to other running systems, I examined its architecture and tools.

Having tried to install Apache 2 Web Server on this device, I could better appreciate how to run services on the Raspberry Pi and when I set up a web server on a Linux-based system.
## session 8 (consolidate)
Acknowledging low-level programming These days, I rather well grasp low-level programming as well as high-level languages, assembly, and machine code interface with hardware. This has let me grasp the basic concepts guiding interactions between hardware and software.

Working with Raspberry Pi and applying CPUlator hands-on has helped me to connect theoretical concepts to useful ideas. Changing screens or interacting with other components, I now see how code influences hardware.

Studying operating systems has taught me to see how smoothly computers are operated by means of kernel, system utilities, and user interfaces cooperating as well as how operating systems govern resources and processes. Learning Linux has let me study how different operating systems approach tasks and how best to interact with them.

Development and Problem Solving: My ability to solve problems has improved especially with the Assembler and C programming projects. Now, I know to divide difficult activities into reasonable steps whether developing programming or installing web servers.
