[Contents](../personal_learning_record/personal_learning_record.md) | [Segment 2 - Languages and OS](../personal_learning_record/segment2.md) 

# Segment 2 - Languages and Operating Systems

## session 5
Machine Code, Assembly Code, and High-Level Languages:
Machine code consists of binary instructions directly executed by the processor. Assembly code is a human-readable version of machine code, which an assembler translates into machine code. High-level languages like C, Java, and Python allow for easy expression of complex tasks and are translated into machine code for execution.

ARM Assembler and C Programming:
I’ve been introduced to ARM Assembler and C programming using CPUlator, which helps me understand how assembly code interacts with hardware and how C code gets translated into machine code.

Subroutines and Stacks:
We’ve looked at subroutines (small reusable blocks of code) and how stacks are used in programming. Understanding this helps me structure programs more efficiently and manage memory effectively.

Interrupts:
Interrupts allow the processor to respond to external events, halting its current process and allowing it to handle urgent tasks. Learning about interrupts is essential for managing hardware resources and multitasking.

Assembler Examples:
By looking at assembler examples, I’ve gained a clearer understanding of how programs are constructed and how low-level instructions control hardware components like registers and memory.

## session 6
Structure of a Modern Operating System:
I’ve started studying the structure of modern operating systems, which has given me insights into how they manage resources, hardware, and software to ensure smooth operation of tasks and services.

Assembler and C Code on CPUlator:
I’ve continued exploring Assembler and C code, particularly in simulating and controlling 7-segment displays on CPUlator. This exercise has enhanced my understanding of how low-level programming can manipulate hardware components.

Using Assembler and C on the Raspberry Pi:
I’ve moved on to applying Assembler and C programming to the Raspberry Pi, taking my learning beyond simulation and allowing me to work with real-world hardware. This hands-on experience deepens my understanding of how to interface with actual devices.
## session 7
Operating System Kernel Functions:
In Session 6, I learned about the core functions of an operating system kernel. This gave me insight into how the kernel manages hardware resources, system processes, and provides essential services for software applications.

Operating System Structure:
In this session, I began exploring the wider structure of operating systems, focusing on the different components and how they work together. This included understanding how user interfaces, system utilities, and various system services are organized.

Linux Operating System:
I explored the structure and utilities of Linux, learning about its unique features and how it differs from other operating systems in terms of file management, process handling, and system configuration.

Installing Apache 2 Web Server on Raspberry Pi:
I attempted to install the Apache 2 web server on my Raspberry Pi, which helped me understand the process of setting up a web server on a Linux-based system and how to manage services on the Raspberry Pi.

## session 8 (consolidate)
Understanding Low-Level Programming:
I've gained a solid understanding of how low-level programming works, including how machine code, assembly, and high-level languages interact with the hardware. This has given me a clearer picture of the fundamental operations behind software and hardware interactions.

Hands-on Experience with Hardware:
The hands-on work with Raspberry Pi and using tools like CPUlator has helped me connect theoretical concepts to practical applications. I now have a better grasp of how code manipulates hardware, whether it's controlling displays or interacting with external components.

Exploring Operating Systems:
I’ve learned how operating systems manage resources and processes, particularly how kernels, system utilities, and user interfaces work together to run a system smoothly. The exploration of Linux has shown me how operating systems handle tasks differently and how to work with them more effectively.

Development and Problem Solving:
The exercises, particularly around programming in Assembler and C, have enhanced my problem-solving skills. I’ve learned to break down complex tasks into manageable steps, whether writing code or configuring services like web servers.

